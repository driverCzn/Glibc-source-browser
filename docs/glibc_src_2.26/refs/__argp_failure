<dec f='glibc_src_2.26/argp/argp.h' l='489' type='void __argp_failure(const struct argp_state *restrict __state, int __status, int __errnum, const char *restrict __fmt)'/>
<use f='glibc_src_2.26/argp/argp-help.c' l='224' u='c' c='fill_in_uparams'/>
<use f='glibc_src_2.26/argp/argp-help.c' l='235' u='c' c='fill_in_uparams'/>
<use f='glibc_src_2.26/argp/argp-help.c' l='247' u='c' c='fill_in_uparams'/>
<def f='glibc_src_2.26/argp/argp-help.c' l='1812' ll='1889' type='void __argp_failure(const struct argp_state * state, int status, int errnum, const char * fmt)'/>
<use f='glibc_src_2.26/argp/argp-help.c' l='1891' c='argp_failure'/>
<doc f='glibc_src_2.26/argp/argp-help.c' l='1804'>/* Similar to the standard gnu error-reporting function error(), but will
   respect the ARGP_NO_EXIT and ARGP_NO_ERRS flags in STATE, and will print
   to STATE-&gt;err_stream.  This is useful for argument parsing code that is
   shared between program startup (when exiting is desired) and runtime
   option parsing (when typically an error code is returned instead).  The
   difference between this function and argp_error is that the latter is for
   *parsing errors*, and the former is for other problems that occur during
   parsing but don&apos;t reflect a (syntactic) problem with the input.  */</doc>
