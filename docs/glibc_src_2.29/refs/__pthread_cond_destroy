<dec f='glibc_src_2.29/nptl/pthreadP.h' l='482' type='int __pthread_cond_destroy(pthread_cond_t * cond)'/>
<use f='glibc_src_2.29/nptl/cnd_destroy.c' l='25' u='c' c='cnd_destroy'/>
<def f='glibc_src_2.29/nptl/forward.c' l='117' macro='1' type='int __pthread_cond_destroy(pthread_cond_t * cond)'/>
<use f='glibc_src_2.29/nptl/nptl-init.c' l='93'/>
<use f='glibc_src_2.29/nptl/nptl-init.c' l='93'/>
<def f='glibc_src_2.29/nptl/pthread_cond_destroy.c' l='41' ll='60' type='int __pthread_cond_destroy(pthread_cond_t * cond)'/>
<use f='glibc_src_2.29/nptl/pthread_cond_destroy.c' l='61' c='pthread_cond_destroy'/>
<doc f='glibc_src_2.29/nptl/pthread_cond_destroy.c' l='28'>/* See __pthread_cond_wait for a high-level description of the algorithm.

   A correct program must make sure that no waiters are blocked on the condvar
   when it is destroyed, and that there are no concurrent signals or
   broadcasts.  To wake waiters reliably, the program must signal or
   broadcast while holding the mutex or after having held the mutex.  It must
   also ensure that no signal or broadcast are still pending to unblock
   waiters; IOW, because waiters can wake up spuriously, the program must
   effectively ensure that destruction happens after the execution of those
   signal or broadcast calls.
   Thus, we can assume that all waiters that are still accessing the condvar
   have been woken.  We wait until they have confirmed to have woken up by
   decrementing __wrefs.  */</doc>
