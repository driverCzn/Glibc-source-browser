<def f='glibc_src_2.31/sysdeps/nptl/futex-internal.h' l='168' ll='173' type='void futex_wait_simple(unsigned int * futex_word, unsigned int expected, int private)'/>
<doc f='glibc_src_2.31/sysdeps/nptl/futex-internal.h' l='161'>/* Like futex_wait but does not provide any indication why we stopped waiting.
   Thus, when this function returns, you have to always check FUTEX_WORD to
   determine whether you need to continue waiting, and you cannot detect
   whether the waiting was interrupted by a signal.  Example use:
     while (atomic_load_relaxed (&amp;futex_word) == 23)
       futex_wait_simple (&amp;futex_word, 23, FUTEX_PRIVATE);
   This is common enough to make providing this wrapper worthwhile.  */</doc>
<use f='glibc_src_2.31/nptl/pthread_barrier_destroy.c' l='51' u='c' c='pthread_barrier_destroy'/>
<use f='glibc_src_2.31/nptl/pthread_barrier_wait.c' l='126' u='c' c='__pthread_barrier_wait'/>
<use f='glibc_src_2.31/nptl/pthread_barrier_wait.c' l='184' u='c' c='__pthread_barrier_wait'/>
<use f='glibc_src_2.31/nptl/pthread_cond_common.c' l='280' u='c' c='__condvar_acquire_lock'/>
<use f='glibc_src_2.31/nptl/pthread_cond_common.c' l='416' u='c' c='__condvar_quiesce_and_switch_g1'/>
<use f='glibc_src_2.31/nptl/pthread_cond_destroy.c' l='54' u='c' c='__pthread_cond_destroy'/>
<use f='glibc_src_2.31/nptl/allocatestack.c' l='975' u='c' c='setxid_mark_thread'/>
<use f='glibc_src_2.31/nptl/allocatestack.c' l='1132' u='c' c='__nptl_setxid'/>
<use f='glibc_src_2.31/nptl/allocatestack.c' l='1239' u='c' c='__wait_lookup_done'/>
<use f='glibc_src_2.31/nptl/allocatestack.c' l='1262' u='c' c='__wait_lookup_done'/>
<use f='glibc_src_2.31/nptl/pthread_create.c' l='583' u='c' c='start_thread'/>
<use f='glibc_src_2.31/nptl/pthread_once.c' l='105' u='c' c='__pthread_once_slow'/>
