<dec f='glibc_src_2.31/crypt/sha256.h' l='66' type='void * __sha256_finish_ctx(struct sha256_ctx * ctx, void * resbuf)'/>
<use f='glibc_src_2.31/crypt/sha256-crypt.c' l='74' u='c' c='__sha256_crypt_r'/>
<use f='glibc_src_2.31/crypt/sha256-crypt.c' l='74' u='c' c='__sha256_crypt_r'/>
<use f='glibc_src_2.31/crypt/sha256-crypt.c' l='74' u='c' c='__sha256_crypt_r'/>
<use f='glibc_src_2.31/crypt/sha256-crypt.c' l='74' u='c' c='__sha256_crypt_r'/>
<use f='glibc_src_2.31/crypt/sha256-crypt.c' l='74' u='c' c='__sha256_crypt_r'/>
<use f='glibc_src_2.31/crypt/sha256-crypt.c' l='373' u='c' c='__sha256_crypt_r'/>
<doc f='glibc_src_2.31/crypt/sha256.h' l='61'>/* Process the remaining bytes in the buffer and put result from CTX
   in first 32 bytes following RESBUF.

   IMPORTANT: On some systems it is required that RESBUF is correctly
   aligned for a 32 bits value.  */</doc>
<def f='glibc_src_2.31/crypt/sha256.c' l='110' ll='140' type='void * __sha256_finish_ctx(struct sha256_ctx * ctx, void * resbuf)'/>
<doc f='glibc_src_2.31/crypt/sha256.c' l='105'>/* Process the remaining bytes in the internal buffer and the usual
   prolog according to the standard and write the result to RESBUF.

   IMPORTANT: On some systems it is required that RESBUF is correctly
   aligned for a 32 bits value.  */</doc>
