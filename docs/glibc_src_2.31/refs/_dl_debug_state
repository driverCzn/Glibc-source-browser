<dec f='glibc_src_2.31/sysdeps/generic/ldsodefs.h' l='1010' type='void _dl_debug_state()'/>
<doc f='glibc_src_2.31/sysdeps/generic/ldsodefs.h' l='1006'>/* The dynamic linker calls this function before and having changing
   any shared object mappings.  The `r_state&apos; member of `struct r_debug&apos;
   says what change is taking place.  This function&apos;s address is
   the value of the `r_brk&apos; member.  */</doc>
<use f='glibc_src_2.31/elf/dl-close.c' l='502' u='c' c='_dl_close_worker'/>
<use f='glibc_src_2.31/elf/dl-close.c' l='810' u='c' c='_dl_close_worker'/>
<use f='glibc_src_2.31/elf/dl-debug.c' l='60' u='a' c='_dl_debug_initialize'/>
<def f='glibc_src_2.31/elf/dl-debug.c' l='71' ll='74' type='void _dl_debug_state()'/>
<doc f='glibc_src_2.31/elf/dl-debug.c' l='67'>/* This function exists solely to have a breakpoint set on it by the
   debugger.  The debugger is supposed to find this function&apos;s address by
   examining the r_brk member of struct r_debug, but GDB 4.15 in fact looks
   for this particular symbol name in the PT_INTERP file.  */</doc>
<use f='glibc_src_2.31/elf/dl-open.c' l='606' u='c' c='dl_open_worker'/>
