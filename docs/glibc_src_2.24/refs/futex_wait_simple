<def f='glibc_src_2.24/sysdeps/nptl/futex-internal.h' l='131' ll='136' type='void futex_wait_simple(unsigned int * futex_word, unsigned int expected, int private)'/>
<doc f='glibc_src_2.24/sysdeps/nptl/futex-internal.h' l='124'>/* Like futex_wait but does not provide any indication why we stopped waiting.
   Thus, when this function returns, you have to always check FUTEX_WORD to
   determine whether you need to continue waiting, and you cannot detect
   whether the waiting was interrupted by a signal.  Example use:
     while (atomic_load_relaxed (&amp;futex_word) == 23)
       futex_wait_simple (&amp;futex_word, 23, FUTEX_PRIVATE);
   This is common enough to make providing this wrapper worthwhile.  */</doc>
<use f='glibc_src_2.24/nptl/pthread_barrier_destroy.c' l='51' u='c' c='pthread_barrier_destroy'/>
<use f='glibc_src_2.24/nptl/pthread_barrier_wait.c' l='126' u='c' c='__pthread_barrier_wait'/>
<use f='glibc_src_2.24/nptl/pthread_barrier_wait.c' l='184' u='c' c='__pthread_barrier_wait'/>
<use f='glibc_src_2.24/nptl/allocatestack.c' l='988' u='c' c='setxid_mark_thread'/>
<use f='glibc_src_2.24/nptl/allocatestack.c' l='1142' u='c' c='__nptl_setxid'/>
<use f='glibc_src_2.24/nptl/allocatestack.c' l='1253' u='c' c='__wait_lookup_done'/>
<use f='glibc_src_2.24/nptl/allocatestack.c' l='1276' u='c' c='__wait_lookup_done'/>
<use f='glibc_src_2.24/nptl/pthread_create.c' l='587' u='c' c='start_thread'/>
<use f='glibc_src_2.24/nptl/pthread_once.c' l='105' u='c' c='__pthread_once_slow'/>
<use f='glibc_src_2.24/nptl/pthread_rwlock_rdlock.c' l='68' u='c' c='__pthread_rwlock_rdlock_slow'/>
<use f='glibc_src_2.24/nptl/pthread_rwlock_wrlock.c' l='67' u='c' c='__pthread_rwlock_wrlock_slow'/>
<use f='glibc_src_2.24/nptl/unregister-atfork.c' l='117' u='c' c='__unregister_atfork'/>
